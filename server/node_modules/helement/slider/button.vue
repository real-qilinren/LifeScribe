<template>
  <div class="fd-slider-button"
       @mousedown="handleMouseDown($event)"
       @mouseup="handleMouseUp"
       :style="buttonStyle">
    <div class="fd-button"></div>
  </div>
</template>
<script type="text/javascript">
  export default {
    name: 'button',
    props: {
      // 按钮绑定值
      value: {
        type: Number,
        default: 0
      }
    },
    data() {
      return {
        scope: {
          // 按钮绑定值
          value: this.value,
          dragging: false,
          currentX: 0,
          startX: 0,
          startPosition: 0,
          newPosition: 0
        }
      }
    },
    watch: {
      value: {
        deep: true,
        handler(newVal, oldVal) {
          this.scope.value = newVal;
        }
      }
    },
    computed: {
      max() {
        return this.$parent.scope.max;
      },
      min() {
        return this.$parent.scope.min;
      },
      currentPosition() {
        return `${ (this.scope.value - this.min) / (this.max - this.min) * 100 }%`;
      },
      buttonStyle() {
        return {
          left: (this.scope.value - this.min) / (this.max - this.min) * 100 + '%'
        }
      },
      precision() {
        let precisions = [this.min, this.max, this.$parent.scope.step].map(item => {
          let decimal = ('' + item).split('.')[1];
          return decimal ? decimal.length : 0;
        });
        return Math.max.apply(null, precisions);
      }
    },
    methods: {
      // 鼠标按下的事件
      handleMouseDown(event) {
        let _this = this;
        _this.scope.dragging = true;
        _this.scope.startX = event.clientX;
        _this.scope.startPosition = parseFloat(this.currentPosition);

        // 鼠标拖拽事件
        document.onmousemove = (event) => {
          if(_this.scope.dragging) {
            _this.scope.currentX = event.clientX;
            // 计算相对于当前slider 移动了多少百分比
            let diff = (_this.scope.currentX - _this.scope.startX) / _this.$parent.sliderSize * 100;
            // 最新位置
            _this.scope.newPosition = _this.scope.startPosition + diff;
            _this.setPosition(_this.scope.newPosition);
          }
        }

      },
      // 鼠标抬起事件
      handleMouseUp() {
        this.scope.dragging = false;
      },
      // 最新位置变化时  计算是否移动一个间隔 这个间隔相对于当前元素分段
      setPosition(newPosition) {
        if (newPosition === null || isNaN(newPosition)) return;
        // 范围限制  不能小于0% 不能大于100%
        if (newPosition < 0) {
          newPosition = 0;
        } else if (newPosition > 100) {
          newPosition = 100;
        }
        // 这里是计算value值
        let value = newPosition * (this.max - this.min) * 0.01 + this.min;
        value = parseFloat(value.toFixed(this.precision));
        this.$emit('input', value);
      }
    },
    mounted() {

    }
  }
</script>
